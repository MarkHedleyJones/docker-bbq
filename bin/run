#!/usr/bin/env bash

TESTING="${TESTING:=False}"

# The path to check for contanier specific workspaces
path_global_workspace="/home/${USER}/workspaces"
dirname_workspace="workspace"
verbosity=0
interactive=0

testing() {
  if [[ "${TESTING}" != "False" ]]; then
    if [[ $# -eq 2 ]]; then
      echo "$1=$2"
    elif [[ $# -eq 1 ]]; then
      echo "$1"
    fi
  fi
}

info() {
  if [[ "${verbosity}" != "0" ]]; then
    echo "$@"
  fi
}

absolute_path() {
  echo "$(cd "$(dirname "$1")" || return; pwd)/$(basename "$1")"
}

find_repo_name() {
  # Crawl up tree to find Docker file, in order to find directory/repo name
  image=NULL
  repository_path="$(absolute_path "$1")"
  while [[ ${repository_path} != "/" ]]; do
    if [[ -f "${repository_path}/Dockerfile" ]]; then
      image=$(basename "${repository_path}")
      return 0
    fi
    repository_path=$(dirname "${repository_path}")
  done
  repository_path=NULL
  return 1
}

get_docker_images() {
  docker_images_clean=($(docker image list --format "{{.Repository}}" --filter=reference='*:latest'))
  docker_images_full=($(docker image list --format "{{.Repository}}:{{.Tag}}" --filter=dangling=false))
}

list_docker_images() {
  get_docker_images
  for image in "${docker_images_clean[@]}"; do
    echo "${image}"
  done
  exit 0
}

parse_image_and_tag_input() {
  if [[ $# -ne 1 ]]; then
    input_image=NULL
    input_tag=NULL
  elif [[ "${1}" =~ ":" ]]; then
    # Split the image into its image and tag components
    IFS=':' read -r input_image input_tag <<< "${1}:"
  else
    input_image="${1}"
    input_tag="latest"
  fi
  testing "user_image" "${input_image}"
  testing "user_tag" "${input_tag}"
}

set_container_name() {
  # Controls the format of container names
  if [[ $# -ne 2 ]]; then
    error "Error naming container"
  fi
  container_name="${1}-${2}"
}

set_workspace_path() {
  # Controls the format of container names
  if [[ $# -ne 1 ]]; then
    error "Error setting workspace paths"
  fi
  if [[ "${repository_path}" != "" ]]; then
    if [[ -f "${repository_path}/.docker-flow" ]]; then
      local_workspace="${1}"
      image_workspace="/${dirname_workspace}"
    else
      info "Repository does not contain a .docker-flow file" \
           "- no workspace will be mounted"
    fi
  fi
}

error() {
  # Print the error, in red, then exit
  if [[ $# -eq 1 ]]; then
    echo -e "\033[0;31m$1\033[0m"
  fi
  exit 1
}

usage() {
  cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [image-source] [command]

  Enter a docker container and optionally execute a command. If no command is
  given, drop into an interactive bash shell.

  The image-source will be determined the following checks:
  1. Check to see if the user is currently in a docker-flow repository.
  2. Check to see if the first argument is a path to docker-flow repository.
  3. Check to see if the first argument is a path inside a docker-flow repository.
  4. Check to see if the first argument is the name of an available local image.
  5. Assume the first argument is the name of an image on docker-hub

  Once the image-source is decided, check if the image is already running.
  If so, reuse the existing image. If not, start a new image using docker run.

OPTIONS:

  -h, --help      Print this help and exit
  -l, --list      Print the list of docker images and exit

EXAMPLES:

  $(basename "${BASH_SOURCE[0]}") ~/repos/debian-buster-slim

  Drop into the bash shell of a docker-flow repository at specified path.
EOF
  exit
}

# Parse parameters
while :; do
  case "${1-}" in
  -h | --help) usage ;;
  -l | --list) list_docker_images ;;
  -v | --verbose) verbosity=1 ;;
  -n | --non-interactive) interactive=0 ;;
  -?*) error "Unknown option: $1" ;;
  *) break ;;
  esac
  shift
done

find_repo_name "$(pwd)"
testing "image-from-working-dir" "${image}"

container_workdir="/${dirname_workspace}"
command=""

if [[ "${image}" != "NULL" ]]; then
  # We are inside a docker-flow repository
  tag="latest"
  set_container_name "${image}" "${tag}"
  set_workspace_path "${repository_path}/${dirname_workspace}"
  container_workdir="$(pwd | sed "s|${repository_path}||")"
  if [[ ${container_workdir} = "" ]]; then
    container_workdir="/"
  fi
else
  if [[ $# -eq 0 ]]; then
    error "Could not find a docker-flow repository in this working tree"
  elif [[ -d "$1" ]] || [[ -f "$1" ]]; then
    # The user passed a path
    find_repo_name "$1"
    if [[ "${image}" != "NULL" ]]; then
      tag="latest"
      set_container_name "${image}" "${tag}"
      set_workspace_path "${repository_path}/${dirname_workspace}"
      if [[ -f "$1" ]]; then
        # User has specified a specifc file,  so execute that
        testing "target argument is a file"
        command="$(echo "$(absolute_path "$1")" | sed "s|${repository_path}/${dirname_workspace}/|./|")"
      elif [[ -d "$1" ]]; then
        testing "target argument is a directory"
        container_workdir="$(echo "$(absolute_path "$1")" | sed "s|${repository_path}||")"
      fi
      # Remove the processed argument ($1) as it has been processed
      shift
    else
      error "Could not find a docker-flow repository at (or above) $1"
    fi
  else
    get_docker_images
    parse_image_and_tag_input "${1}"
    shift
    if [[ " ${docker_images_full[*]} " =~ " ${input_image}:${input_tag} " ]]; then
      testing "target argument was found in docker image list"
      image=${input_image}
      tag=${input_tag}
      set_container_name "${image}" "${tag}"
      container_workdir="/"
    else
      if [[ "${input_image}" =~ "/" ]]; then
        IFS='/' read -r -a parts <<< "${input_image}/"
        if [[ " ${docker_images_full[*]} " =~ " ${parts[0]}:latest " ]]; then
          image=${parts[0]}
          tag="latest"
          set_container_name "${image}" "${tag}"
          set_workspace_path "${path_global_workspace}/${image}"
        else
          error "Could not find the docker image ${input_image}:${input_tag}"
        fi
      else
        error "Could not find the docker image ${input_image}:${input_tag}"
      fi
    fi
  fi
fi

# Collect the remaining arguments as the command
if [[ $# -gt 0 ]]; then
  if [[ "${command}" != "" ]]; then
    command+=" "
  fi
  command+="$*"
fi

testing "image" "${image}"
testing "tag" "${tag}"
testing "container_name" "${container_name}"
testing "local_workspace" "${local_workspace}"
testing "image_workspace" "${image_workspace}"
testing "container_workdir" "${container_workdir}"
testing "command" "${command}"

docker_args_workdir+="--workdir=${container_workdir} "
if [[ "${image_workspace}" != "" ]]; then
  # WORKDIR should be set inside the container, but just-in-case, set it again.
  # Allows scripts inside the container to easily locate the workspace
  docker_args_workdir+="--env WORKDIR=/${dirname_workspace} "
fi

# Setup a local bash_history file to link into the container
bash_history_path="/tmp/.bash_history_${container_name}"
if [[ ! -f "${bash_history_path}" ]]; then
  # Touch file to so docker wont create it as a dir with root permissions
  touch "${bash_history_path}"
fi
docker_args_bash_history="-v ${bash_history_path}:/root/.bash_history "

docker_args_mount_workdir=""
if [[ "${local_workspace}" != "" ]] && [[ "${image_workspace}" != "" ]]; then
  if [[ "${path_global_workspace}" == "USED" ]] && [[ ! -d ${local_workspace} ]]; then
    mkdir "${local_workspace}"
    info "Created global workspace folder at ${local_workspace}"
  fi
  docker_args_mount_workdir="-v ${local_workspace}:${image_workspace} "
fi

docker_command="/usr/bin/env bash"
if [[ "${command}" != "" ]]; then
  docker_command="/usr/bin/env bash -cl \"${command}\""
fi

docker_args_interactive=""
if [[ "${interactive}" -eq 1 ]]; then
  docker_args_interactive="--interactive --tty "
fi

if [[ ! $(docker ps --quiet --filter name="${container_name}") ]]; then
  info "Running in new container (${image}:${tag})"

  if [[ ${local_workspace} != "" ]]; then
    info "Linking ${local_workspace} into ${image}:${image_workspace}"
  fi

  docker_args_display=""
  if [[ ${DISPLAY} ]]; then
    xsock=/tmp/.X11-unix
    xauth=/tmp/.docker.xauth
    touch $xauth
    xauth nlist "${DISPLAY}" | sed -e 's/^..../ffff/' | xauth -f "${xauth}" nmerge -

    docker_args_display+="-e DISPLAY "
    docker_args_display+="-e XAUTHORITY=${xauth} "
    docker_args_display+="-v ${xauth}:${xauth}:rw "
    docker_args_display+="-v ${xsock}:${xsock}:rw "

    if command -v nvidia-smi > /dev/null; then
      # Enable Nvidia specific features
      docker_args_display+="--gpus=all "
      docker_args_display+="-e NVIDIA_DRIVER_CAPABILITIES=all "
      docker_args_display+="--env QT_X11_NO_MITSHM=1 "
    fi
  fi

  # Setup the user
  docker_args_user="--env GID=$(id -g) --env UID=$(id -u) "

  eval "docker run \
    --hostname ${image} \
    --name ${container_name} \
    --net host \
    --privileged \
    --rm \
    ${docker_args_interactive} \
    ${docker_args_bash_history} \
    ${docker_args_display} \
    ${docker_args_mount_workdir} \
    ${docker_args_user} \
    ${docker_args_workdir} \
    ${image}:${tag} \
    ${docker_command}"

  if [[ ${image_workspace} != "" ]]; then
    # Recursively set permissions of workspace folder
    fix_permission_command="chown --recursive --from=\$(id -u):\$(id -g) "
    fix_permission_command+="$(id -u):$(id -g) ${image_workspace}"

    eval "docker run \
      --rm \
      --entrypoint="" \
      ${docker_args_mount_workdir} \
      ${image}:${tag} \
      /usr/bin/env bash -c '${fix_permission_command}'"
  fi
else
  info "Running in existing container (${image}:${tag})"
  eval docker exec \
    "${docker_args_interactive}" \
    "${docker_args_workdir}" \
    "${container_name}" \
    "${docker_command}"
fi
