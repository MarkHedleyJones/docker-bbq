#!/usr/bin/env bash

image=NULL

# Locate Dockerfile to determine image name
project_path=$(pwd)
while [[ ${project_path} != "/" ]]; do
    if [[ -f ${project_path}/Dockerfile ]]; then
        image=$(basename ${project_path})
        break
    fi
    project_path=$(dirname ${project_path})
done

local_path=$(pwd)
container_path=$(pwd | sed "s|${project_path}||")
if [[ "${container_path}" == "" ]]; then
  container_path="/"
fi

tag=latest

if [[ ${image} == NULL ]]; then
    if [[ $# != 1 ]]; then
        echo "Couldnt find a Dockerfile this or any parent directory - aborting!"
        exit 1
    else
        if [[ "${1}" =~ ":" ]]; then
            parts=(${1//:/ })
            image=${parts[0]}
            tag=${parts[1]}
        else
          image=${1}
        fi
        shift
    fi
    workspace_dirname=""
    local_workspace=""
    image_workspace=""
    docker_args_user=""
    docker_args_workdir=""
    docker_args_mount_workdir=""
else
    workspace_dirname="workspace"
    local_workspace="${project_path}/${workspace_dirname}"
    image_workspace="/${workspace_dirname}"
    # Setup the workspace
    if [[ ! -d ${local_workspace} ]]; then
        mkdir -p ${local_workspace}
    fi
    # Setup the user
    docker_args_user="--env GID=$(id -g) --env UID=$(id -u) "

    # WORKDIR should be set inside the container, but just-in-case, set it again.
    # Allows scripts inside the container to easily locate the workspace
    docker_args_workdir+="--env WORKDIR=${image_workspace} "

    # Allow the user to execute commands with paths as if they were in the container
    docker_args_workdir+="--workdir=${container_path} "
    docker_args_mount_workdir="-v ${local_workspace}:${image_workspace} "
fi

docker_command="/usr/bin/env bash"
if [[ ${#} -gt 0 ]]; then
    docker_command="/usr/bin/env bash -cl \"$@\""
fi

if [[ ! $(docker ps --quiet --filter name=${image}) ]]; then
  echo "Running in new container (${image}:${tag})"

  xsock=/tmp/.X11-unix
  xauth=/tmp/.docker.xauth
  touch $xauth
  xauth nlist ${DISPLAY} | sed -e 's/^..../ffff/' | xauth -f ${xauth} nmerge -

  docker_args_display="-e DISPLAY "
  docker_args_display+="-e XAUTHORITY=${xauth} "
  docker_args_display+="-v ${xauth}:${xauth}:rw "
  docker_args_display+="-v ${xsock}:${xsock}:rw "
  docker_args_display+="--gpus=all "
  docker_args_display+="-e NVIDIA_DRIVER_CAPABILITIES=all "
  docker_args_display+="--env QT_X11_NO_MITSHM=1 "

  eval docker run \
      ${docker_args_interactive} \
      --name ${image} \
      --rm \
      --privileged \
      --net=host \
      --interactive \
      --tty \
      ${docker_args_display} \
      ${docker_args_user} \
      ${docker_args_mount_workdir} \
      ${docker_args_workdir} \
      ${image}:${tag} \
      ${docker_command}

  if [[ ${workspace_dirname} != "" ]]; then
    # Recursively set permissions of workspace folder
    fix_permission_command="chown --recursive --from=\$(id -u):\$(id -g) "
    fix_permission_command+="$(id -u):$(id -g) ${image_workspace}"
    docker run \
        --rm \
        --entrypoint="" \
        ${docker_args_mount_workdir} \
        ${image}:${tag} \
        /usr/bin/env bash -c "${fix_permission_command}"
  fi
else
  echo "Running in existing container (${image}:${tag})"
  eval docker exec \
    --interactive \
    --tty \
    ${docker_args_workdir} \
    ${image} \
    ${docker_command}
fi
