#!/usr/bin/env bash

image=NULL

# Locate Dockerfile to determine image name
project_path=$(pwd)
while [[ ${project_path} != "/" ]]; do
    if [[ -f ${project_path}/Dockerfile ]]; then
        image=$(basename "${project_path}")
        break
    fi
    project_path=$(dirname "${project_path}")
done

container_path=$(pwd | sed "s|${project_path}||")
if [[ "${container_path}" == "" ]]; then
  container_path="/"
fi

tag=latest
local_workspace=""
image_workspace=""
docker_args_workdir=""
docker_args_mount_workdir=""

# The path to check for contanier specific workspaces
global_workspace="/home/${USER}/workspaces"

# Has the user specified an image to use?
if [[ $# -ge 2 ]] &&  [[ "${1}" == "--image" ]]; then
    shift
    if [[ "${1}" =~ ":" ]]; then
        # Split the image into its image-name and tag components
        IFS=':' read -r image tag <<< "${1}:"
        # if image=debian tag=stretch then want dirname -> debian-stretch
        local_workspace_dirname=${image}-${tag}
    else
      image=${1}
      # a locally created container is likely to have 'latest' tag, but we
      # don't want to create new workspaces for every tag, so just use ${image}
      local_workspace_dirname=${image}
    fi
    shift
    # Check to see if the user has defined a global workspaces folder
    if [[ -d ${global_workspace} ]]; then
        workspace_dirname="workspace"
        local_workspace=${global_workspace}/${local_workspace_dirname}
        image_workspace="/${workspace_dirname}"
        docker_args_workdir=""
        docker_args_workdir+="--workdir=${image_workspace} "
        global_workspace="USED"  # Flag to indicate use of a global workspace
    else
        echo "Could not find ~/workspaces folder to use as a global workspace"
    fi
elif [[ ${image} == NULL ]]; then
    echo "Couldnt find a Dockerfile in this or any parent directory - aborting!"
    echo ""
    echo "TIP: You can specify an image using the --image <image name> switch"
    echo "Example: run --image debian:buster [command]"
    exit 1
else
    # Check that an image with this tag exists
    if [[ "$(docker image list -q "${image}")" == "" ]]; then
      echo "ERROR: Project '${image}' is missing a docker image - aborting!"
      exit 1
    fi
    workspace_dirname="workspace"
    local_workspace="${project_path}/${workspace_dirname}"
    # If the repository contains a workspace folder, link it into the image
    if [[ -d ${local_workspace} ]]; then
      image_workspace="/${workspace_dirname}"
      if [[ "${container_path}" != "" ]]; then
          # Allow the user to execute commands with paths as if in the container
          docker_args_workdir+="--workdir=${container_path} "
      fi
    else
      echo "This repository does not contain a workspace folder - not linking"
    fi

fi

if [[ "${image_workspace}" != "" ]]; then
    # WORKDIR should be set inside the container, but just-in-case, set it again.
    # Allows scripts inside the container to easily locate the workspace
    docker_args_workdir+="--env WORKDIR=${image_workspace} "
fi

if [[ "${local_workspace}" != "" ]] && [[ "${image_workspace}" != "" ]]; then
    if [[ "${global_workspace}" == "USED" ]] && [[ ! -d ${local_workspace} ]]; then
      mkdir "${local_workspace}"
      echo "Created global workspace folder at ${local_workspace}"
    fi
    docker_args_mount_workdir="-v ${local_workspace}:${image_workspace} "
fi

docker_command="/usr/bin/env bash"
if [[ ${#} -gt 0 ]]; then
    docker_command="/usr/bin/env bash -cl \"$*\""
fi

container_name=${image}-${tag}

if [[ ! $(docker ps --quiet --filter name="${container_name}") ]]; then
  echo "Running in new container (${image}:${tag})"

  if [[ ${local_workspace} != "" ]]; then
    echo "Linking ${local_workspace} into ${image}:${image_workspace}"
  fi

  docker_args_display=""
  if [[ ${DISPLAY} ]]; then
    xsock=/tmp/.X11-unix
    xauth=/tmp/.docker.xauth
    touch $xauth
    xauth nlist "${DISPLAY}" | sed -e 's/^..../ffff/' | xauth -f "${xauth}" nmerge -

    docker_args_display+="-e DISPLAY "
    docker_args_display+="-e XAUTHORITY=${xauth} "
    docker_args_display+="-v ${xauth}:${xauth}:rw "
    docker_args_display+="-v ${xsock}:${xsock}:rw "

    if command -v nvidia-smi > /dev/null; then
      # Enable Nvidia specific features
      docker_args_display+="--gpus=all "
      docker_args_display+="-e NVIDIA_DRIVER_CAPABILITIES=all "
      docker_args_display+="--env QT_X11_NO_MITSHM=1 "
    fi
  fi

  # Setup the user
  docker_args_user="--env GID=$(id -g) --env UID=$(id -u) "

  eval "docker run \
      --name ${container_name} \
      --rm \
      --privileged \
      --net=host \
      --interactive \
      --tty \
      ${docker_args_display} \
      ${docker_args_user} \
      ${docker_args_mount_workdir} \
      ${docker_args_workdir} \
      ${image}:${tag} \
      ${docker_command}"

  if [[ ${image_workspace} != "" ]]; then
    # Recursively set permissions of workspace folder
    fix_permission_command="chown --recursive --from=\$(id -u):\$(id -g) "
    fix_permission_command+="$(id -u):$(id -g) ${image_workspace}"
    docker run \
        --rm \
        --entrypoint="" \
        "${docker_args_mount_workdir}" \
        "${image}:${tag}" \
        /usr/bin/env bash -c "${fix_permission_command}"
  fi
else
  echo "Running in existing container (${image}:${tag})"
  eval docker exec \
    --interactive \
    --tty \
    "${docker_args_workdir}" \
    "${container_name}" \
    "${docker_command}"
fi
